
const heroShader = new Shader(Shader.source('clay.standard.vertex'), Shader.source('hero.fragment'));

const app = application.create(this.$el.querySelector('#viewport'), {

    graphic: {
        shadow: true
    },

    init(app) {
        const camera = app.createCamera([40, 20, 50], [0, 15, 0]);

        const dirLight = app.createDirectionalLight([-10, -10, -5]);
        dirLight.shadowResolution = 2048;
        dirLight.shadowBias = 0.005;

        app.createAmbientLight('#fff', 0.2);

        this._control = new plugin.OrbitControl({
            domElement: app.container,
            target: camera
        });

        return Promise.all([
            this._loadRocks(app),
            this._loadHero(app, heroName),
            this._loadAnimation(app, heroName)
        ]).then(result => {
            for (let skeleton of this._modelResult.skeletons) {
                skeleton.addClip(this._currentClip);
                app.timeline.addClip(this._currentClip);
            }
        });
    },

    _loadRocks(app) {
        return app.loadModel('assets/rock/rocks.gltf').then(result => {
            let rockMaterial = app.createMaterial({
                shader: heroShader,
                diffuseMap: 'assets/rock/textures/badside_rocks001.png',
                maskMap2: 'assets/rock/textures/badside_rocks001_spec.png',
                textureFlipY: false
            });
            let rootNode = result.rootNode;
            rootNode.position.set(-5, 0, 0);
            rootNode.scale.set(0.15, 0.15, 0.15);

            for (let mesh of result.meshes) {
                mesh.geometry.generateTangents();
                mesh.material = rockMaterial;
            };
        });
    },

    _loadHero(app, heroName) {
        const heroRootPath = 'heroes/' + heroName + '/';
        return Promise.all([
            app.loadModel(heroRootPath + heroName + '.gltf'),
            fetch(heroRootPath + 'materials.json').then(response => response.json())
        ]).then(result => {
            const modelResult = result[0];
            const materialResult = result[1];

            modelResult.rootNode.scale.set(0.15, 0.15, 0.15);

            // Override the materials
            let newMaterials = {};
            for (let matName in materialResult) {
                let matConfig = Object.assign({
                    shader: heroShader,
                    textureFlipY: false
                }, materialResult[matName]);
                let newMat = app.createMaterial(matConfig);
                newMaterials[matName] = newMat;
            }
            for (let mesh of modelResult.meshes) {
                mesh.geometry.generateTangents();
                mesh.material = newMaterials[mesh.material.name];

                util.mesh.splitByJoints(mesh, 30, true);
                // mesh.material.define('fragment', 'RENDER_NORMAL');
            }

            this._modelResult = modelResult;
        });
    },

    _loadAnimation(app, heroName) {
        const heroRootPath = 'heroes/' + heroName + '/';
        return fetch(heroRootPath + 'animations.json')
            .then(response => response.json())
            .then(animations => {
                let defaultAnim = animations['default'] || animations['idle'][0];
                return this._loadAnimationClip(app, defaultAnim.path);
            });
    },

    _loadAnimationClip(app, animationPath) {
        return fetch(animationPath)
            .then(response => response.text())
            .then(smdData => {
                const clip = readSMD(smdData);
                this._currentClip = clip;
                return clip;
            });
    },

    loop(app) {
        this._control.update(app.frameTime);
    }
});